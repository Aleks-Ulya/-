## Определение дерева

### Дерево — это тип графа, который не содержит циклов и в котором существует единственный путь между любыми двумя вершинами. 
### Его отличительные особенности:
Выделена одна вершина, называемая корнем, а остальные вершины располагаются на уровнях ниже корня. Ребра ориентированы от корня к листьям (конечным вершинам). Каждая вершина, кроме корня, имеет ровно одно входящее ребро, то есть только одну связь, ведущую к ней. Примерами деревьев служат структура организации файлов на компьютере, родословные и многие другие иерархические системы.

## Определение графа

### Граф﻿ — это абстрактная структура, включающая множество точек (вершин) и линий (рёбер), которые их соединяют. 
### Основные свойства графов:
Граф может быть направленным, где рёбра имеют определённое направление, или ненаправленным, с двунаправленными рёбрами. Кроме того, графы бывают взвешенными, если каждому ребру приписан вес, и невзвешенными — без весов. Примерами графов служат социальные сети, карты дорог, электрические цепи и другие подобные системы.

## Реализация деревьев и графов на Python, Java и C++

Пример дерева на Python:

class TreeNode: def init(self, value): self.value = value self.children = [] 
#
    def add_child(self, child):
        self.children.append(child)

## Использование

root = TreeNode(1)
root.add_child(TreeNode(2))
root.add_child(TreeNode(3))

## Анализ:
Класс TreeNode предназначен для моделирования узла дерева, в котором сохраняется значение текущей вершины и список её дочерних элементов. Такая структура легко дополняется новыми методами для выполнения поиска, обхода по узлам и других операций над деревом.

## Пример графа на Java

import java.util.ArrayList; import java.util.List;

class GraphVertex { int id; List neighbors;
#
    public GraphVertex(int id) {
        this.id = id;
        this.neighbors = new ArrayList<>();
    }

    public void addNeighbor(GraphVertex vertex) {
        neighbors.add(vertex);
    }
​

## Использование
GraphVertex A = new GraphVertex(1);
GraphVertex B = new GraphVertex(2);
A.addNeighbor(B);
B.addNeighbor(A);
## Анализ:
Данный способ реализует граф через списки смежности, где каждая вершина содержит перечень своих соседей. Этот подход хорошо подходит для хранения и обновления графовых структур, а также обеспечивает экономное использование памяти.

## Использование
#
    int main() {
    Vertex A(1), B(2);
    A.addNeighbor(&B);
    B.addNeighbor(&A);
    return 0;
    }
## Анализ:

В этой реализации, аналогичной Java, используются указатели на объекты, что повышает производительность и снижает потребление памяти.

Пошаговый разбор алгоритма обхода дерева методом поиска в глубину (DFS) на Python. Рассмотрим простейшую реализацию DFS, которая рекурсивно посещает вершины, отслеживает посещённые узлы и позволяет эффективно обходить структуру дерева для решения различных задач.

def dfs(node): visited = set() stack = [node]
#
    while stack:
    current = stack.pop()
    if current not in visited:
        visited.add(current)
        print(current.value)
        stack.extend(reversed(current.children))

## Пример использования

Вызов функции обхода dfs(root) начинается с корня дерева. Алгоритм работает со стеком, в который помещаются вершины, и продолжает обработку, пока стек не опустеет. Каждая вершина посещается только один раз: сначала выводится её значение, затем в стек добавляются её дочерние узлы в обратном порядке, чтобы обеспечить правильную последовательность обхода.

## Оценка временной сложности:

Время работы алгоритма напрямую зависит от количества вершин и рёбер. Поскольку каждая вершина и каждое ребро обрабатываются ровно один раз, временная сложность алгоритма DFS равна O(N+E), где N — число вершин, а E — число рёбер.
