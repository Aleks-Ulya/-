1.Блочная сортировка 
def bucket_sort(arr):
    """
    Алгоритм блочной сортировки.
    
    Параметры:
    arr (list): Исходный массив для сортировки.
    
    Возвращает:
    list: Отсортированный массив.
    """
    if not arr:
        return arr
    
    # Определение минимального и максимального элементов
    min_val = min(arr)
    max_val = max(arr)
    
    # Число корзин
    num_buckets = len(arr)
    
    # Ширина блока (размах значений, деленный на количество корзин)
    bucket_range = (max_val - min_val) / num_buckets
    
    # Создаем пустые корзины
    buckets = [[] for _ in range(num_buckets)]
    
    # Распределение элементов по корзинам
    for val in arr:
        # Определяем номер корзины для каждого элемента
        idx = int((val - min_val) // bucket_range)
        if idx == num_buckets:
            idx -= 1  # Избегаем выхода за пределы корзин
        buckets[idx].append(val)
    
    # Сортировка внутри каждой корзины
    for i in range(num_buckets):
        buckets[i].sort()
    
    # Объединение отсортированных корзин
    sorted_arr = []
    for bucket in buckets:
        sorted_arr.extend(bucket)
    
    return sorted_arr

# Пример использования
if __name__ == "__main__":
    input_list = [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]
    output_list = bucket_sort(input_list)
    print("Отсортированный массив:", output_list)

Результат выполнения:
Отсортированный массив: [0.1234, 0.3434, 0.565, 0.656, 0.665, 0.897]

2.Блинная сортировка:
def flip(arr, k):
    """Перевертывает первые k+1 элементов массива"""
    arr[:k + 1] = reversed(arr[:k + 1])

def find_max(arr, n):
    """Ищет индекс наибольшего элемента в массиве размером n"""
    return max(range(n), key=arr.__getitem__)

def pancake_sort(arr):
    """
    Основная функция блинной сортировки
    
    Параметры:
    arr -- исходный список для сортировки
    Возвращаемое значение:
    Отсортированный список
    """
    curr_size = len(arr)
    
    # Проходим по всему списку, уменьшая размер на каждом шаге
    while curr_size > 1:
        # Шаг 1: Найти индекс самого большого элемента в текущей части списка
        max_idx = find_max(arr, curr_size)
        
        if max_idx != curr_size - 1:
            # Если самый большой элемент находится не на последнем месте,
            # сначала переворачиваем его наверх
            if max_idx != 0:
                flip(arr, max_idx)
            
            # Теперь переворачиваем весь остаток массива,
            # таким образом, ставя максимальный элемент на последнее место
            flip(arr, curr_size - 1)
        
        # Уменьшаем область поиска, исключив последний элемент
        curr_size -= 1
    
    return arr

# Пример использования
if __name__ == "__main__":
    example_arr = [23, 10, 20, 11, 12]
    print("Исходный массив:", example_arr)
    sorted_arr = pancake_sort(example_arr)
    print("Отсортированный массив:", sorted_arr)

Результат выполнения:
Исходный массив: [23, 10, 20, 11, 12] 
Отсортированный массив: [10, 11, 12, 20, 23]

3.Сортировка бусинами:
def bead_sort(array):
    """
    Сортирует массив неотрицательных целых чисел с использованием метода сортировки бусинами.
    
    array: Список неотрицательных целых чисел.
    Возвращает: Отсортированный список.
    """
    # Проверка валидности аргументов
    if any(not isinstance(x, int) or x < 0 for x in array):
        raise ValueError('Список должен содержать только неотрицательные целые числа')

    # Нахождение максимальной величины в списке
    max_value = max(array)

    # Создание двумерного массива 'решетки' для представления 'стержней'
    beads = [[False]*len(array) for _ in range(max_value)]

    # Установка значений True в решетке согласно числам в массиве
    for i, num in enumerate(array):
        for j in range(num):  # Заполняем столько строк, сколько указано числом
            beads[j][i] = True

    # Имитация "падения" бусин путем перемещения всех истинных значений вниз
    for col in range(len(beads[0])):
        count_true = sum(row[col] for row in beads)  # Подсчет количества "упавших" бусин
        for row in range(count_true):
            beads[row][col] = True  # Устанавливаем true снизу вверх
        for row in range(count_true, len(beads)):
            beads[row][col] = False  # Оставляем false выше упавших бусин

    # Преобразование обратно в отсортированные числа
    result = []
    for col in range(len(beads[0])):
        count_true = sum(row[col] for row in beads)  # Сколько бусин упало в данном столбце
        result.append(count_true)

    return result


# Тестирование примера
array_to_sort = [5, 3, 1, 8, 2, 4, 7, 6]
sorted_array = bead_sort(array_to_sort)
print(f"Исходный массив: {array_to_sort}")
print(f"Отсортированный массив: {sorted_array}")

Результат выполнения:
Исходный массив: [5, 3, 1, 8, 2, 4, 7, 6]
Отсортированный массив: [5, 3, 1, 8, 2, 4, 7, 6]

4.Поиск скачками:
import math

def jump_search(arr, target):
    """
    Осуществляет поиск заданного элемента в отсортированном массиве используя алгоритм Jump Search.
    
    :param arr: Отсортированный массив целых чисел
    :param target: Целое число, которое ищем
    :return: Индекс первого появления элемента или -1, если элемент отсутствует
    """
    length = len(arr)
    step = int(math.sqrt(length))  # Рассчитываем длину прыжка
    
    prev = 0  # Начальная точка для проверки

    # Продолжаем прыгать, пока не достигнем конца массива или пока текущий элемент меньше цели
    while arr[min(step, length)-1] < target:
        prev = step  # Сохраняем предыдущее местоположение
        step += int(math.sqrt(length))  # Двигаемся дальше
        if prev >= length:  # Если вышли за пределы массива, значит элемент отсутствует
            return -1
    
    # Последовательный поиск внутри окна между предыдущей точкой и следующей точкой
    while arr[prev] <= target and prev < min(step, length):
        if arr[prev] == target:
            return prev  # Нашли элемент!
        prev += 1
    
    return -1  # Элемент не найден

# Пример использования
if __name__ == "__main__":
    data = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]
    target = 13
    index = jump_search(data, target)
    if index != -1:
        print(f"Элемент {target} найден на индексе {index}.")
    else:
        print(f"Элемент {target} не найден.")

Результат выполнения:
Элемент 13 найден на индексе 6. \

5.Экспоненциальный поиск:
import bisect

def exponential_search(arr, target):
    """
    Экспоненциальный поиск элемента в отсортированном массиве.
    
    Параметры:
    arr (list): Отсортированный массив
    target (int): Искомый элемент
    
    Возвращает:
    Индекс элемента, если он найден, иначе -1.
    """
    n = len(arr)
    
    # Особый случай: пустой массив
    if n == 0:
        return -1
    
    # Начало поиска с первой позиции
    bound = 1
    
    # Экспоненциальный рост границ
    while bound < n and arr[bound] < target:
        bound *= 2  # Удваиваем границу поиска
    
    # Теперь знаем, что нужный элемент находится между bound//2 и min(bound, n-1)
    left = bound // 2
    right = min(bound, n-1)
    
    # Применяем бинарный поиск в суженном диапазоне
    pos = bisect.bisect_left(arr, target, left, right+1)
    
    # Проверяем, действительно ли найден элемент
    if pos < n and arr[pos] == target:
        return pos
    else:
        return -1

# Пример использования
if __name__ == "__main__":
    arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]
    target = 13
    result = exponential_search(arr, target)
    if result != -1:
        print(f"Элемент {target} найден на позиции {result}.")
    else:
        print(f"Элемент {target} не найден.")

Результат выполнения:
Элемент 13 найден на позиции 6.  

6.Тернарный поиск:
def ternary_search(arr, target):
    """
    Алгоритм тернарного поиска для поиска целевого элемента в отсортированном массиве.
    
    Параметры:
    arr (list): Отсортированный массив
    target (int): Целевое значение для поиска
    
    Возвращает:
    Индекса элемента, если он найден, иначе -1.
    """
    left = 0                   # Левая граница поиска
    right = len(arr) - 1       # Правая граница поиска
    
    while left <= right:
        mid1 = left + (right-left)//3          # Первая средняя точка (первая треть)
        mid2 = right - (right-left)//3         # Вторая средняя точка (вторая треть)
        
        # Проверка средней точки слева
        if arr[mid1] == target:
            return mid1                        # Нашли элемент в первой трети
        
        # Проверка средней точки справа
        elif arr[mid2] == target:
            return mid2                         # Нашли элемент во второй трети
        
        # Сокращение диапазона поиска
        elif target < arr[mid1]:               # Если элемент левее первой середины
            right = mid1 - 1                    # Сдвигаем правую границу
        elif target > arr[mid2]:               # Если элемент правее второй середины
            left = mid2 + 1                     # Сдвигаем левую границу
        else:                                  # Если элемент лежит между серединами
            left = mid1 + 1
            right = mid2 - 1
    
    return -1                                  # Элемент не найден

# Пример использования
if __name__ == "__main__":
    arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]
    target = 13
    result = ternary_search(arr, target)
    if result != -1:
        print(f"Элемент {target} найден на позиции {result}.")
    else:
        print(f"Элемент {target} не найден.")

Результат выполнения:
Элемент 13 найден на позиции 6.       
