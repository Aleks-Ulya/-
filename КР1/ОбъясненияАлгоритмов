                          Алгоритмы сортировки
1.Определение: 
Блочная сортировка (bucket sort) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. После этого каждая корзина сортируется отдельно (либо тем же методом рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив. 
2.Объяснение работы алгоритма:
 1.Определяется количество корзин (например, по диапазону значений элементов).
    n = len(arr)
 2.Каждый элемент помещается в корзину согласно функции распределения. 
    max_value = max(arr)
    min_value = min(arr)
    interval = (max_value - min_value + 1) / n
 3.Содержимое каждой корзины сортируется индивидуально. 
    sorted_arr = []
    for bucket in buckets:
        sorted_bucket = sorted(bucket)
        sorted_arr.extend(sorted_bucket)
 4.Корзины соединяются в порядке увеличения диапазона. 
3.Временная сложность:
Распространение элементов по ведрам занимает O(N), поскольку проходит однократный проход по всему массиву.
4.Краткое объяснение оценки временной сложности алгоритмa:
Эффективна для равномерно распределённых числовых данных и может достигать линейной асимптотики O(n), если размер корзин выбран удачно. Однако эффективность сильно падает при неравномерном распределении данных. 

1.Определение:
Блинная сортировка (pancake sort) — это метод, основанный на операции переворота (reversal) части массива. В отличие от большинства алгоритмов, которые обменивают соседние элементы или выбирают опорные точки, здесь единственная разрешённая операция — переворот префикса массива до выбранного индекса. 
2.Объяснение работы алгоритма:
 1.Найти максимальный элемент в неотсортированной части массива. 
def find_max(arr, n):
 2.Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот элемент оказался первым. 
def flip(arr, k):
    arr[:k + 1] = reversed(arr[:k + 1])
 3.Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце. 
flip(arr, curr_size - 1)
 4.Повторить процесс для оставшейся неотсортированной части массива. 
3.Временная сложность:
O(N2)
4.Краткое объяснение оценки временной сложности алгоритмa:
Функция find_max() выполняется за O(N), поскольку проходит по каждому элементу массива, чтобы найти максимальное значение. Операция переворота flip() также требует O(k), где k — длина отрезка массива, подлежащего перевороту. Но фактически это операция порядка O(N). Количество итераций основного цикла зависит от длины массива N, каждая итерация включает два переворота и одно вычисление индекса максимального элемента.

1.Определение: 
Сортировка бусинами (bead sort), также известная как гравитационная сортировка, моделирует естественное поведение бусин, падающих вниз под действием гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл Диннин в 2002 году. 
2.Объяснение работы алгоритма:
 1.Каждый элемент массива представляется в виде горизонтального ряда бусин, количество которых соответствует его значению. 
 2.Бусины располагаются на «стержнях» (как на абаке). 
 beads = [[False]*len(array) for _ in range(max_value)]
 3.Под действием «гравитации» бусины падают вниз. 
for col in range(len(beads[0])):
        count_true = sum(row[col] for row in beads) 
 4.После оседания бусин строки считываются сверху вниз — получается отсортированный массив. 
  count_true = sum(row[col] for row in beads) 
3.Временная сложность:
 О(⌈m/n⌉ × n²)
4.Краткое объяснение оценки временной сложности алгоритмa:
Для больших чисел временная сложность резко возрастает, делая алгоритм неэффективным на практике. Однако для небольших объемов данных и ограниченного диапазона чисел этот метод выглядит интересным и демонстрирует необычный подход к решению задачи сортировки.
                        Алгоритмы поиска
1.Определение:
Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного диапазона. 
2.Объяснение работы алгоритма:
 1.Делится массив на блоки длины m=n. 
 2.Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный искомому. 
prev = 0                     
    while arr[min(prev + step, n) - 1] < target:
 3.Если найденный элемент больше искомого, выполняется линейный поиск в предыдущем блоке. 
if prev >= n:           
            return -1 
3.Временаая сложность:
В среднем сложность поиска O(N)
4.Краткое объяснение оценки временной сложности алгоритмa:
Jump Search подходит для случаев, когда доступ к данным организован через массивы, и существует необходимость быстрого поиска в частично структурированной среде. Он быстрее линейного поиска, но немного уступает бинарному поиску по скорости.

1.Определение:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя быстро определить диапазон, в котором может находиться искомое значение, а затем применяет двоичный поиск в этом диапазоне. 
2.Объяснение работы алгоритма:
 1.Проверяется первый элемент массива. 
  bound = 1
 2.Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д., пока не будет найден элемент, больше или равный искомому. 
 while bound < n and arr[bound] < target:
        bound *= 2 
 3.На найденном диапазоне выполняется бинарный поиск. 
pos = bisect.bisect_left(arr, target, left, right+1)
3.Временная сложность:
O(log ⁡n). 
4.Краткое объяснение оценки временной сложности алгоритмa:
Эффективен при поиске в очень больших отсортированных массивах с неизвестным размером или частичным доступом. 

1.Определение:
Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или экстремум функции (в зависимости от задачи). 
2.Объяснение работы алгоритма:
 1.Делится диапазон индексов на три части. 
    left = 0                   
    right = len(arr) - 1 
 2.Сравнивается искомый элемент с элементами на двух разделительных границах.
 if arr[mid1] == target:
            return mid1                    
elif arr[mid2] == target:
            return mid2  
 3.Если совпадение не найдено, алгоритм повторяется рекурсивно в одной из трети массива, где может находиться искомое значение. 
  return -1 
3.Временная сложность:
O(log ⁡n)
4.Краткое объяснение оценки временной сложности алгоритмa:
Сложность также O(log⁡n), но число сравнений на шаг выше, чем в двоичном поиске. Экспоненциальный поиск эффективен даже на больших массивах благодаря своей логарифмической сложности.
