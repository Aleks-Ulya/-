                                                                       АЛГОРИТМЫ СОРТИРОВКИ
Анализ алгоритма: Сортировка выбором (Selection Sort)
Определение:
Сортировка выбором - это простой алгоритм, который последовательно выбирает наименьший элемент из неотсортированной части массива и помещает его в начало отсортированной части.
Анализ:
Алгоритм сортировки выбором проходит по массиву, находит наименьший элемент и ставит его на первое место, повторяя процесс для оставшихся элементов. Временная сложность этого метода — O(n2)O(n2), что делает его неэффективным для больших объемов данных. Пространственная сложность — O(1)O(1), так как используется минимальное дополнительное пространство памяти.

Сортировка обменом (пузырьком) (Bubble Sort) 
Определение:
Сортировка обменом (пузырьком) (Bubble Sort) -это простой метод сортировки, в котором соседние элементы попарно сравниваются и меняются местами, пока весь массив не станет упорядоченным. Алгоритм многократно проходит по списку, постепенно сдвигая большие значения («пузыри») к концу списка. 
Анализ:
Сортировка пузырьком последовательно сравнивает соседние элементы массива и меняет их местами, если порядок нарушен. Каждый проход гарантирует, что максимальный элемент попадает в конец массива. Временная сложность этого алгоритма — O(n2)O(n2), что делает его неэффективным для больших массивов.

Сортировка вставками (Insertion Sort) 
Определение:
Сортировка вставками (Insertion Sort) - это простой алгоритм сортировки, который последовательно берет каждый элемент массива и вставляет его на правильную позицию среди уже отсортированных элементов. Он напоминает способ, которым многие люди раскладывают карты в руке, размещая каждую карту на нужное место по мере добавления новых карт.
Анализ:
Сортировка вставками последовательно берёт каждый элемент массива и вставляет его на правильную позицию среди уже отсортированных элементов. Временная сложность алгоритма в худшем и среднем случаях составляет O(n2)O(n2), но в лучшем случае (уже отсортированный массив) достигает O(n)O(n). Алгоритм эффективен для небольших или частично отсортированных массивов, но непригоден для обработки больших наборов данных.

Сортировка слиянием (Merge Sort)
Определение:
Сортировка слиянием (Merge Sort) - это эффективный алгоритм сортировки, использующий стратегию "разделяй и властвуй": массив рекурсивно делится на части, каждая из которых сортируется отдельно, после чего отсортированные части объединяются в единую последовательность. Временная сложность алгоритма — O(nlog⁡n)O(nlogn), что делает его предпочтительным выбором для больших объемов данных. 
Анализ:
Сортировка слиянием делит массив на две части, рекурсивно сортируя каждую, а затем объединяет отсортированные части. В процессе объединения выбираются наименьшие элементы из обеих половин и собираются в единый отсортированный массив. Временная сложность алгоритма — $O(n\log n)$, что делает его эффективным решением для больших объемов данных.

Сортировка Шелла (Shellsort)
Определение:
Сортировка Шелла (Shellsort) - идея метода заключается в предварительном сравнении элементов, находящихся на расстоянии друг от друга (интервал называется шагом), а не только смежных элементов, как в обычной сортировке вставками. Постепенное уменьшение шага позволяет быстро приблизить массив к отсортированному состоянию, после чего применяется обычная сортировка вставками для окончательного упорядочивания.
Анализ:
Сортировка Шелла улучшает обычную сортировку вставками путём предварительного упорядочивания элементов, расположенных далеко друг от друга (используя определённые шаги), что ускоряет конечную сортировку. Величина шага постепенно уменьшается от половины длины массива до 1, позволяя эффективно распределять элементы на ранних этапах. Теоретически сложность варьируется от O(n(log⁡n)2)O(n(logn)2) до O(n1.5)O(n1.5), в зависимости от выбора последовательности шагов. Оптимальные стратегии позволяют достичь близкую к оптимальной производительности.

Быстрая сортировка (Quick Sort) 
Определение:
Быстрая сортировка (Quick Sort) - это эффективный алгоритм сортировки, основанный на принципе "разделяй и властвуй". Он выбирает опорный элемент, делит массив на две части (элементы меньше и больше опорного), рекурсивно сортирует их и соединяет. Средняя временная сложность — O(nlog⁡n)O(nlogn).
Анализ:
Выделяется опорный элемент, все элементы, меньшие или равные ему, отправляются влево, а большие — направо. Процедура повторяется рекурсивно для каждой стороны, пока весь массив не будет отсортирован. Средняя временная сложность алгоритма — O(nlog⁡n)O(nlogn), в худшем случае (очень редко) — O(n2)O(n2).

Пирамидальная сортировка 
Определение:
Пирамидальная сортировка (Heap Sort) - это алгоритм сортировки, основанный на структуре данных бинарная куча (binary heap). Основные этапы работы пирамидальной сортировки включают построение двоичной кучи из входящего массива, удаление корня кучи (самого большого элемента) и размещение его в правильном положении отсортированного массива, повторяя этот процесс до полной сортировки.
Анализ:
Построение кучи (создание max-кучи). Удаление корней (наибольших элементов) и восстановление свойств кучи. Временная сложность алгоритма — O(nlog⁡n)O(nlogn) для любого случая.

                                                                        АЛГОРИТМЫ ПОИСКА
Последовательный (линейный) поиск
Определение:
Последовательный (линейный) поиск - это простой алгоритм поиска элемента в списке или массиве, при котором элементы просматриваются последовательно один за другим, начиная с первого, до нахождения искомого элемента или достижения конца списка. Линейный поиск применяется, когда структура данных неупорядоченна или когда невозможно применить более эффективные алгоритмы поиска (например, бинарный поиск). Временная сложность линейного поиска в худшем случае составляет O(n)O(n), где nn — количество элементов в списке.
Анализ:
Скрипт осуществляет прямой последовательный просмотр элементов массива от начала до конца. Как только обнаруживается совпадение с искомым значением, немедленно возвращается индекс этого элемента. Временная сложность алгоритма в худшем случае — O(n)O(n), где nn — количество элементов в списке.

Бинарный (двоичный, дихотомический) поиск 
Определение:
Бинарный (двоичный, дихотомический) поиск - это эффективный алгоритм поиска элемента в отсортированном массиве или списке. Вместо последовательного перебора элементов, алгоритм делит массив на две части и ищет нужный элемент только в той половине, где он предположительно находится, основываясь на сравнении среднего элемента с искомым. Бинарный поиск существенно сокращает количество сравнений, работая за время O(log⁡n)O(logn), где nn — количество элементов в массиве.
Анализ:
Алгоритм сокращает область поиска вдвое на каждой итерации, что делает его чрезвычайно быстрым для больших отсортированных массивов. Максимальная глубина деления соответствует высоте бинарного дерева — примерно log⁡2nlog2​n, где nn — количество элементов. Временная сложность алгоритма — O(log⁡n)O(logn), что намного эффективнее последовательного поиска.

Интерполирующий поиск
Определение:
Интерполирующий поиск - это усовершенствованный вариант бинарного поиска, предназначенный для работы с большими упорядоченными наборами данных, особенно когда распределение элементов равномерно. В отличие от классического бинарного поиска, который всегда делит интервал пополам, интерполирующий поиск предсказывает положение искомого элемента, исходя из распределения данных. Это позволяет быстрее находить требуемые значения, снижая количество итераций поиска.
Анализ: 
Алгоритм пытается угадать положение искомого элемента, учитывая его возможное расположение между двумя граничными значениями. Чем точнее распределение данных, тем быстрее работает поиск, поскольку алгоритм способен сразу перейти близко к нужному элементу. Временная сложность в лучшем случае — O(log⁡log⁡n)O(loglogn), в худшем — O(n)O(n) (если данные плохо распределены).

Поиск по Фибоначчи
Определение:
Поиск по Фибоначчи (Fibonacci Search) — это модификация бинарного поиска, применяемая для поиска элемента в отсортированном массиве. Основное отличие от бинарного поиска заключается в том, что деление массива происходит не посередине, а в пропорциях, соответствующих числам Фибоначчи. За счет такого подхода достигается высокая скорость поиска при работе с большими объемами данных, особенно если доступ к данным неравномерный или дорог по стоимости (например, чтение с диска).
Анализ:
Сначала создается последовательность чисел Фибоначчи подходящей длины. Путем многократного уменьшения размеров интервалов поиска (согласно числам Фибоначчи) ищется оптимальное положение элемента. Временная сложность алгоритма поиска по Фибоначчи аналогична бинарному поиску и составляет O(log⁡n)O(logn).
