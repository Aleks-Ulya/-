# 1.Задание 4. Жадный алгоритм: покрытие множества
## Условие: 
Дано семейство подмножеств. Выбрать минимальное число подмножеств, покрывающих все элементы.
## Алгоритм: 
жадный выбор подмножества с максимальным числом новых элементов
# 2.Описание работы алгоритма:
1.Инициализируем пустое множество для хранения уже покрытых элементов.
covered = set()

2.Инициализируем пустой список для хранения выбранных подмножеств.
result = []

3.Основной цикл: продолжаем, пока не покрыли все элементы вселенной.
while len(covered) < len(universe)

4.Обнуляем «лучшее» подмножество перед поиском.
best = None

5.Устанавливаем счётчик максимального числа новых элементов в ноль.
max_new_elements = 0

6.Перебираем все подмножества для поиска оптимального.
for subset in subsets

7.Вычисляем, сколько новых (ещё не покрытых) элементов содержит текущее подмножество.
new_elements = len(subset - covered)

8.Если текущее подмножество даёт больше новых элементов, чем предыдущие:
if new_elements > max_new_elements


9.Если не нашлось подмножества, добавляющего новые элементы — завершаем цикл.
if best is None or max_new_elements == 0

10.Добавляем найденное лучшее подмножество в итоговый список.
result.append(best)

11.Обновляем множество покрытых элементов, добавляя все элементы из выбранного подмножества.
covered.update(best)

12.Возвращаем список выбранных подмножеств после завершения цикла.
return result
# 3.Временная сложность
O(n)×O(m)×O(k)=O(n⋅m⋅k)
# 4.Описание временной сложности
На каждую из n итераций внешнего цикла мы выполняем m итераций внутреннего цикла, и на каждой такой итерации тратим O(k) времени на проверку элементов. Поэтому общая сложность складывается как произведение. 
Это означает, что время работы алгоритма растёт линейно с увеличением:
числа элементов во вселенной (n),
количества подмножеств (m),
размера самых больших подмножеств (k).
# 5.Ответ на контрольный вопрос
Жадный алгоритм для вершинного покрытия 2-аппроксимирует оптимальное решение, потому что он выбирает ребра, которые образуют паросочетание — множество непересекающихся ребер. Каждое ребро этого паросочетания покрывается хотя бы одной вершиной из оптимального решения, значит оптимальное покрытие не меньше по размеру, чем количество выбранных ребер. Алгоритм выбирает по 2 вершины на ребро, то есть размер решения максимум в 2 раза больше оптимального. Размер покрытия жадного алгоритма не более 2х оптимального, то есть 2-аппроксимация.
